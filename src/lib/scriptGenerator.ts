import type {
	MapLocalAction,
	MapRemoteAction,
	RewriteBodyAction,
	Rule,
	ThrottleAction,
} from "../types/rules";

/**
 * Generates a mitmproxy Python script from a RelayCraft Rule.
 * This is a "best effort" deterministic generation.
 */
/**
 * Format a date to a local datetime string (YYYY-MM-DD HH:mm:ss)
 * More user-friendly for local desktop applications than ISO 8601 UTC
 */
function formatLocalDateTime(date: Date): string {
	const year = date.getFullYear();
	const month = String(date.getMonth() + 1).padStart(2, "0");
	const day = String(date.getDate()).padStart(2, "0");
	const hours = String(date.getHours()).padStart(2, "0");
	const minutes = String(date.getMinutes()).padStart(2, "0");
	const seconds = String(date.getSeconds()).padStart(2, "0");
	return `${year}-${month}-${day} ${hours}:${minutes}:${seconds}`;
}

export function generateScriptFromRule(rule: Rule): string {
	const timestamp = formatLocalDateTime(new Date());
	const headers = [
		`"""`,
		`Generated by RelayCraft at ${timestamp}`,
		`Rule: ${rule.name}`,
		`Type: ${rule.type}`,
		`"""`,
		`from mitmproxy import http`,
		`import re`,
		`import json`,
		``,
	].join("\n");

	const actions = rule.actions || [];
	const indent = "    ";
	const matchLogic = generateMatchLogic(rule, indent);

	const hasJsonAction = actions.some(
		(a) => a.type === "rewrite_body" && a.json,
	);

	const requestSnippets: string[] = [];
	const responseSnippets: string[] = [];

	const jsonHelper = hasJsonAction
		? `
def apply_json_modification(data, path, value, operation):
    try:
        from jsonpath_ng import parse
        import jsonpath_ng
        jsonpath_expr = parse(path)
        matches = jsonpath_expr.find(data)
        if not matches: return
        if operation == "set":
            jsonpath_expr.update(data, value)
        elif operation == "append":
            for match in matches:
                if isinstance(match.value, list):
                    match.value.append(value)
        elif operation == "delete":
            for match in matches:
                if not match.context: continue
                parent = match.context.value
                if isinstance(parent, list) and isinstance(match.path, jsonpath_ng.Index):
                    parent.pop(match.path.index)
                elif isinstance(parent, dict) and isinstance(match.path, jsonpath_ng.Fields):
                    for field in match.path.fields:
                        if field in parent: del parent[field]
    except Exception as e:
        print(f"JSONPath error for '{path}': {e}")
`
		: "";

	actions.forEach((action) => {
		if (action.type === "map_local") {
			requestSnippets.push(generateMapLocalSnippet(action, indent + indent));
		} else if (action.type === "map_remote") {
			requestSnippets.push(generateMapRemoteSnippet(action, indent + indent));
		} else if (action.type === "rewrite_header") {
			const reqSnippet = generateHeaderOperationsSnippet(
				"request",
				action.headers.request,
				indent + indent,
			);
			const resSnippet = generateHeaderOperationsSnippet(
				"response",
				action.headers.response,
				indent + indent,
			);
			if (reqSnippet) requestSnippets.push(reqSnippet);
			if (resSnippet) responseSnippets.push(resSnippet);
		} else if (action.type === "rewrite_body") {
			const snippet = generateRewriteBodySnippet(action, indent + indent);
			if (action.target === "request") requestSnippets.push(snippet);
			else responseSnippets.push(snippet);
		} else if (action.type === "block_request") {
			requestSnippets.push(generateBlockRequestSnippet(indent + indent));
		} else if (action.type === "throttle") {
			// Both request and response can be throttled in the engine, but usually request
			requestSnippets.push(generateThrottleSnippet(action, indent + indent));
		}
	});

	let scriptBody = "";

	if (requestSnippets.length > 0) {
		scriptBody += `\ndef request(flow: http.HTTPFlow) -> None:\n${indent}${matchLogic}:\n${requestSnippets.join("\n")}\n`;
	}

	if (responseSnippets.length > 0) {
		scriptBody += `\ndef response(flow: http.HTTPFlow) -> None:\n${indent}${matchLogic}:\n${responseSnippets.join("\n")}\n`;
	}

	return `${headers}${jsonHelper}\n${scriptBody}`;
}

function generateMatchLogic(rule: Rule, _indent: string): string {
	const conditions: string[] = [];
	const match = rule.match || { request: [], response: [] };
	const atoms = [...(match.request || []), ...(match.response || [])]; // Simplification for script generation, usually scripts match request

	atoms.forEach((atom) => {
		let condition = "";
		if (atom.type === "url") {
			const val = atom.value as string;
			if (atom.matchType === "exact" || atom.matchType === "equals") {
				condition = `flow.request.url == "${val}"`;
			} else if (atom.matchType === "contains") {
				condition = `"${val}" in flow.request.url`;
			} else if (atom.matchType === "regex") {
				condition = `url_match := re.search(r"${val}", flow.request.url)`;
			} else if (atom.matchType === "wildcard") {
				const regex = val
					.replace(/[.+^${}()|[\]\\]/g, "\\$&")
					.replace(/\*/g, ".*")
					.replace(/\?/g, ".");
				condition = `url_match := re.search(r"^${regex}$", flow.request.url)`;
			}
		} else if (atom.type === "host") {
			const val = atom.value as string;
			if (atom.matchType === "exact" || atom.matchType === "equals") {
				condition = `flow.request.host == "${val}"`;
			} else if (atom.matchType === "contains") {
				condition = `"${val}" in flow.request.host`;
			} else if (atom.matchType === "regex") {
				condition = `re.search(r"${val}", flow.request.host)`;
			}
		} else if (atom.type === "path") {
			const val = atom.value as string;
			if (atom.matchType === "exact" || atom.matchType === "equals") {
				condition = `flow.request.path == "${val}"`;
			} else if (atom.matchType === "contains") {
				condition = `"${val}" in flow.request.path`;
			} else if (atom.matchType === "regex") {
				condition = `re.search(r"${val}", flow.request.path)`;
			}
		} else if (atom.type === "method") {
			const vals = Array.isArray(atom.value) ? atom.value : [atom.value];
			if (vals.length > 0) {
				const methodList = vals.map((m) => `"${m}"`).join(", ");
				condition = `flow.request.method in [${methodList}]`;
			}
		} else if (atom.type === "header") {
			const key = atom.key || "";
			const val = (atom.value as string) || "";
			if (atom.matchType === "exact" || atom.matchType === "equals") {
				condition = `flow.request.headers.get("${key}", "") == "${val}"`;
			} else if (atom.matchType === "contains") {
				condition = `"${val}" in flow.request.headers.get("${key}", "")`;
			} else if (atom.matchType === "regex") {
				condition = `re.search(r"${val}", flow.request.headers.get("${key}", "") or "")`;
			} else if (atom.matchType === "exists") {
				condition = `"${key}" in flow.request.headers`;
			} else if (atom.matchType === "not_exists") {
				condition = `"${key}" not in flow.request.headers`;
			}
		} else if (atom.type === "query") {
			const key = atom.key || "";
			const val = (atom.value as string) || "";
			if (atom.matchType === "exact" || atom.matchType === "equals") {
				condition = `flow.request.query.get("${key}", "") == "${val}"`;
			} else if (atom.matchType === "contains") {
				condition = `"${val}" in flow.request.query.get("${key}", "")`;
			} else if (atom.matchType === "regex") {
				condition = `re.search(r"${val}", flow.request.query.get("${key}", "") or "")`;
			} else if (atom.matchType === "exists") {
				condition = `"${key}" in flow.request.query`;
			}
		}

		if (condition) {
			conditions.push(atom.invert ? `not (${condition})` : `(${condition})`);
		}
	});

	if (conditions.length === 0) return "if True";
	return `if ${conditions.join(" and ")}`;
}

function generateMapLocalSnippet(
	action: MapLocalAction,
	indentStr: string,
): string {
	const expandPath = (path: string) => {
		if (path.includes("$")) {
			// r"template".replace("$", "\\") -> python expand format
			const p = path.replace(/\\/g, "\\\\").replace(/"/g, '\\"');
			return `url_match.expand(r"${p}".replace("$", "\\\\")) if "url_match" in locals() else r"${p}"`;
		}
		return `r"${path.replace(/\\/g, "\\\\").replace(/"/g, '\\"')}"`;
	};

	if (action.source === "manual") {
		const content = (action.content || "")
			.replace(/\\/g, "\\\\")
			.replace(/"/g, '\\"')
			.replace(/\n/g, "\\n");
		const finalContent = content.includes("$")
			? `url_match.expand(r"${content}".replace("$", "\\\\")) if "url_match" in locals() else "${content}"`
			: `"${content}"`;

		return `${indentStr}# Map Local (Manual)\n${indentStr}flow.response = http.Response.make(${action.statusCode || 200}, ${finalContent}, {"Content-Type": "${action.contentType || "application/json"}"})`;
	}

	const pathExpr = expandPath(action.localPath || "");

	return `
${indentStr}# Map Local (File)
${indentStr}try:
${indentStr}    local_path = ${pathExpr}
${indentStr}    with open(local_path, "rb") as f:
${indentStr}        content = f.read()
${indentStr}    flow.response = http.Response.make(${action.statusCode || 200}, content, {"Content-Type": "${action.contentType || "application/json"}"})
${indentStr}except Exception as e:
${indentStr}    print(f"Failed to load local file: {e}")
`.trimEnd();
}

function generateMapRemoteSnippet(
	action: MapRemoteAction,
	indentStr: string,
): string {
	const targetUrl = action.targetUrl || "";
	const finalUrl = targetUrl.includes("$")
		? `url_match.expand(r"${targetUrl}".replace("$", "\\\\")) if "url_match" in locals() else "${targetUrl}"`
		: `"${targetUrl}"`;

	return `
${indentStr}# Map Remote
${indentStr}flow.request.url = ${finalUrl}
`.trimEnd();
}

function generateHeaderOperationsSnippet(
	target: "request" | "response",
	operations: { operation: string; key: string; value?: string }[],
	indent: string,
): string {
	return operations
		.map((op) => {
			if (op.operation === "add") {
				return `${indent}flow.${target}.headers.add("${op.key}", "${op.value || ""}")`;
			} else if (op.operation === "set") {
				return `${indent}flow.${target}.headers["${op.key}"] = "${op.value || ""}"`;
			} else if (op.operation === "remove") {
				return `${indent}if "${op.key}" in flow.${target}.headers:\n${indent}    del flow.${target}.headers["${op.key}"]`;
			}
			return "";
		})
		.join("\n");
}

function generateRewriteBodySnippet(
	action: RewriteBodyAction,
	indentStr: string,
): string {
	const event = action.target === "request" ? "request" : "response";
	let bodyLogic = "";

	if (action.set) {
		const escapedContent = (action.set.content || "")
			.replace(/\\/g, "\\\\")
			.replace(/"/g, '\\"')
			.replace(/\n/g, "\\n");
		bodyLogic = `${indentStr}flow.${event}.text = "${escapedContent}"`;
		if (action.set.statusCode) {
			bodyLogic += `\n${indentStr}flow.response.status_code = ${action.set.statusCode}`;
		}
		if (action.set.contentType) {
			bodyLogic += `\n${indentStr}flow.response.headers["Content-Type"] = "${action.set.contentType}"`;
		}
	} else if (action.replace) {
		bodyLogic = `${indentStr}if flow.${event}.text:\n${indentStr}    flow.${event}.text = flow.${event}.text.replace("${action.replace.pattern || ""}", "${action.replace.replacement || ""}")`;
	} else if (action.regex_replace) {
		bodyLogic = `${indentStr}if flow.${event}.text:\n${indentStr}    flow.${event}.text = re.sub(r"${action.regex_replace.pattern || ""}", "${action.regex_replace.replacement || ""}", flow.${event}.text)`;
	} else if (action.json) {
		const innerIndent = indentStr + "        ";
		bodyLogic = `${indentStr}try:
${indentStr}    if flow.${event}.text:
${indentStr}        data = json.loads(flow.${event}.text)
${(action.json.modifications || [])
	.filter((m) => m.enabled !== false)
	.map((m) => generateJsonModification(m, "data", innerIndent))
	.join("\n")}
${indentStr}        flow.${event}.text = json.dumps(data, ensure_ascii=False)
${indentStr}except Exception as e:
${indentStr}    print(f"JSON rewrite failed: {e}")
`.trimEnd();
	}

	return bodyLogic;
}

function generateJsonModification(
	mod: { path: string; operation: string; value?: any },
	varName: string,
	indentStr: string,
): string {
	const safeValue = JSON.stringify(mod.value);
	return `${indentStr}apply_json_modification(${varName}, "${mod.path}", ${safeValue}, "${mod.operation}")`;
}

function generateBlockRequestSnippet(indentStr: string): string {
	return `${indentStr}flow.kill()`;
}

function generateThrottleSnippet(
	action: ThrottleAction,
	indentStr: string,
): string {
	return `${indentStr}import time\n${indentStr}time.sleep(${(action.delayMs || 0) / 1000})`;
}
